---
layout:     post
title:      "JVM"
subtitle:   "JVM初步探究"
date:       2021-03-16 12:00:00
author:     "Pengyujie"
header-img: "img/tag-bg.jpg"
tags:
    - JVM
    - Java

---

>对JVM的初步认识。

<img src="../../../../../img/notes/blog-desktop.jpg" >



<b>JVM构成</b>

​	* 类加载器

​	* 运行时数据区（五大组成）

&ensp; &ensp; &ensp; 1. 程序计数器

&ensp; &ensp; &ensp; 2. 虚拟机栈

&ensp; &ensp; &ensp; 3. 堆

&ensp; &ensp; &ensp; 4. 方法区

&ensp; &ensp; &ensp; 5. 本地方法栈

​	* 执行引擎

​	* 本地库接口

![img](../../../../../img/notes/jvm/jvm.png)



<b>功能作用</b>

Java程序首先被编译成.class文件



加载 - 验证（验证.class文件是否符合规范） - 准备（给静态变量分配地址空间 和默认值） - 解析（符号引用变为直接引用 比如将main()方法 替换为指向数据所存内存的指针或句柄)- 初始化（将静态变量的初始值化为指定的值）

<b>类加载器</b>作用就是加载class文件,将其加载到<b>运行时数据区</b>，
然后由<b>执行引擎</b>将字节码（class文件）翻译成底层系统指令给CPU去
执行，在这个过程中需要调用其他语言的接口<b>本地库接口</b>来实现整个
程序的功能。



## 类加载器



* 虚拟机自带的加载器

* 启动类（根）加载器

* 扩展类加载器

* 应用程序加载器

<b>双亲委派机制</b>
new一个类之后当前加载器就会将其抛给父类 一层一层抛给boot加载器进行查询。
boot加载器没有，就给下一级ext加载器查询，没有再给app加载器查询，过程中只要查询到就执行。
![img](../../../../../img/notes/jvm/jvm_1.png)



## 运行时数据区（五大组成）





<b>程序计数器</b>

<b>内存私有</b>

是一块较小的内存空间，可以当做一个当前线程的所执行字节码的信号指示器

<b>方法区</b>
<b>内存共享</b>
用于存储以及被虚拟机加载的类信息、常量、静态变量、即时编译后的代码数据。反射就是从这方法区读取类信息。

<b>堆</b>
<b>内存共享</b>
堆是Java虚拟机中<b>内存最大</b>的一块,用于存放对象实例。

<b>Java虚拟机栈</b>
<b>内存私有</b>
每一个方法在执行的同时都会创建一个线帧，<b>用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</b>
每一个方法从调用到执行完毕,都对应着一个线帧在虚拟机栈从入栈到出栈的全过程。

<b>本地方法栈</b>
<b>内存私有</b>
与虚拟机栈类型，本地方法栈的线帧存储的是本地方法的信息。



### GC算法 

**标记清除法：**    
进行一次扫描对进行需要活着的对象进行标记，再一次扫描对进行没有标记的对象进行清除。  
好处：不需要额外空间。  
坏处：二次扫描严重浪费时间，会产生内存碎片。  

**标记压缩：**  
就是在标记清除算法的基础上进行一次压缩。

**复制算法：**  
可以将一个区的数据 转移到另一个区 ，保证一个区的绝对干净（年轻代主要用的为复制算法：将to区复制到from区 保证了to区的绝对干净）  

好处：没有内存碎片。  
坏处：浪费内存空间，一半内存空间永远是空to。  
谁空谁是to  

**内存效率：复制算法最优  
内存整齐度：复制算法  
内存利用率：标记压缩和标记压缩**  

缺点：  
标记清除算法会出现内存碎片。  
标记整理算法效率太低。  
复制算法，浪费内存。  

## 执行引擎

是jvm非常核心的组件，用来执行jvm字节码，一般会编译成机器码后执行。


## 本地库接口

调用其他语言本地方法的接口。由接口调用本地方法库去实现程序功能。





## 栈的使用

![img](../../../../../img/notes/jvm/3545372a9e7dfce400d1d1255f0633d8.png)

---



**栈是内存私有的，每个线程都有自己对应的栈，线程会分配一个栈，内部存储对应的局部变量含形参（这个线程每个方法都会在栈中分配一个对应的栈帧来存储这个方法执行过程中的局部变量）**

**对象存放于堆，那么局部变量引用对象，那么栈中的局部变量就会指向堆中对应的对象**

**方法区中存放的是 常量、静态变量、类信息 ，如果是静态变量引用的对象 那么就是方法区中的静态变量指向堆中的方法区**

**PC计数器用来存储，此时执行的代码的内存地址。用于下次上下文切换时，代码继续执行**



---

例子：

比如一个主线程Main方法内部调用一个A方法

~~~java
package com.example.reentrantlock;

public class Test {
    public static void main(String[] args) {
        int a = 1;
        int b = 2;
        int c = 3;

        Test test = new Test();
        test.A();
    }

    public void A(){
        int d = 4;
    }
}

~~~



比如上方的Main方法执行，对应主线程的栈就会有 **main方法的栈帧和对应A方法的栈帧去存对应的变量**。





































