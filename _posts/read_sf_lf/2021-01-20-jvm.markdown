---
layout:     post
title:      "JVM探究"
subtitle:   "对JVM的初步认识"
date:       2021-01-20 12:00:00
author:     "Pengyujie"
header-img: "img/post-bg-rwd.jpg"
tags:
    - Java
    - JVM 
---
>对JVM的初步认识。

<img src="/img/notes/blog-desktop.jpg" >



<b>JVM构成</b>
<br>	* 类加载器
<br>	* 运行时数据区（五大组成）
<br>&ensp; &ensp; &ensp; 1. 程序计数器
<br>&ensp; &ensp; &ensp; 2. 虚拟机栈
<br>&ensp; &ensp; &ensp; 3. 堆
<br>&ensp; &ensp; &ensp; 4. 方法区
<br>&ensp; &ensp; &ensp; 5. 本地方法栈
<br>	* 执行引擎
<br>	* 本地库接口
<br><img src="/img/notes/jvm.png" alt="JVM构成图">

<br><b>功能作用</b>
<br>
<br>Java程序首先被编译成.class文件
<br>
<br>

加载 - 验证（验证.class文件是否符合规范） - 准备（给静态变量分配地址空间 和默认值） - 解析（符号引用变为直接引用 比如将main()方法 替换为指向数据所存内存的指针或句柄)- 初始化（将静态变量的初始值化为指定的值）

<b>类加载器</b>作用就是加载class文件,将其加载到<b>运行时数据区</b>，
然后由<b>执行引擎</b>将字节码（class文件）翻译成底层系统指令给CPU去
执行，在这个过程中需要调用其他语言的接口<b>本地库接口</b>来实现整个
程序的功能。
<br>

## 类加载器

<br>* 虚拟机自带的加载器
<br>* 启动类（根）加载器
<br>* 扩展类加载器
<br>* 应用程序加载器
<br>
<br><b>双亲委派机制</b>
<br>new一个类之后当前加载器就会将其抛给父类 一层一层抛给boot加载器进行查询。
<br>boot加载器没有，就给下一级ext加载器查询，没有再给app加载器查询，过程中只要查询到就执行。
<br><img src="/img/notes/jvm_1.png" >
<br>

## 运行时数据区（五大组成）

<br><b>程序计数器</b>
<br><b>内存私有</b>
<br>是一块较小的内存空间，可以当做一个当前线程的所执行字节码的信号指示器
<br>
<br><b>方法区</b>
<br><b>内存共享</b>
<br>用于存储以及被虚拟机加载的类信息、常量、静态变量、即时编译后的代码数据。反射就是从这方法区读取类信息。
<br>
<br><b>堆</b>
<br><b>内存共享</b>
<br>堆是Java虚拟机中<b>内存最大</b>的一块,用于存放对象实例。
<br>
<br><b>Java虚拟机栈</b>
<br><b>内存私有</b>
<br>每一个方法在执行的同时都会创建一个线帧，<b>用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</b>
每一个方法从调用到执行完毕,都对应着一个线帧在虚拟机栈从入栈到出栈的全过程。
<br>
<br><b>本地方法栈</b>
<br><b>内存私有</b>
<br>与虚拟机栈类型，本地方法栈的线帧存储的是本地方法的信息。
<br>



### gc算法 

标记清除法：    
进行一次扫描对进行需要活着的对象进行标记，再一次扫描对进行没有标记的对象进行清除。  
好处：不需要额外空间。  
坏处：二次扫描严重浪费时间，会产生内存碎片。  

标记压缩：  
就是在标记清除算法的基础上进行一次压缩。


复制算法：  
可以将一个区的数据 转移到另一个区 ，保证一个区的绝对干净（年轻代主要用的为复制算法：将to区复制到from区 保证了to区的绝对干净）  

好处：没有内存碎片。  
坏处：浪费内存空间，一半内存空间永远是空to。  
谁空谁是to  

内存效率：复制算法最优  
内存整齐度：复制算法  
内存利用率：标记压缩和标记压缩  

缺点：  
标记清除算法会出现内存碎片。  
标记整理算法效率太低。  
复制算法，浪费内存。  

## 执行引擎

<br>是jvm非常核心的组件，用来执行jvm字节码，一般会编译成机器码后执行。
<br>

## 本地库接口

<br>调用其他语言本地方法的接口。由接口调用本地方法库去实现程序功能。
<br>

