---
layout:     post
title:      "Java的一些方法"
subtitle:   "方法"
date:       2021-11-06 12:00:00
author:     "Pengyujie"
header-img: "img/tag-bg.jpg"
tags:
    - 方法
    - Java
---



数组对象化

```java
List<JSONParam> list = Arrays.asList(params);//将数组转为 list然后通过 parm将其对象化
Map<String, String> paramMap = new HashMap<String, String>();
for (JSONParam param : list) {
    if(param==null){
        continue;
    }
    paramMap.put(param.getName(), param.getValue());
}
```



一个对象 输出打印(利用反射)

~~~java
Class<? extends YunyingManagerBaseBean> aClass = updateOneById.getClass();
		for (Field field : aClass.getDeclaredFields()) {
			field.setAccessible(true); //设置为true可以直接通过 取消安全检测 反射调优
			String fieldName = field.getName();
			Object value = null;
			try {
				value = field.get(updateOneById);
				System.out.println(fieldName+":"+value);
			} catch (IllegalAccessException e) {
				e.printStackTrace();
			}
		}
~~~



利用BigDecimal进行计算（保留格式小数点后二位）

~~~java

//利用BigDecimal分转为元 保留二位小数
public static String spdValue(String platform_debitcard_top_fee){
    if (!StringUtils.equals(platform_debitcard_top_fee,"0")){
        DecimalFormat decimalFormat = new DecimalFormat("0.00");
        BigDecimal bigDecimal = new BigDecimal(platform_debitcard_top_fee).divide(new BigDecimal("100"));
        platform_debitcard_top_fee = decimalFormat.format(bigDecimal);
    }
    return platform_debitcard_top_fee;
}
~~~



关于加密软件加密的问题，当你用程序生成文件是不会进行加密的（部分加密软件），这时候可以利用程序将文件复制一份即可解决加密问题。代码如下：

~~~java
package com.example.jiami;

import lombok.extern.slf4j.Slf4j;
import java.io.*;

@Slf4j
public class JieMi {
    public static void main(String[] args) {
        String sourceFilePath = "d:\\解密\\"+"原文件"+"\\";//将要解密的原文件放入这个目录下
        String path = "d:\\解密\\" + "已解密文件" + "\\";//文件解密之后会出现在这个目录下
        File file = new File(sourceFilePath);
        if (!file.exists()){
            file.mkdirs();
        }
        File[] sourceFiles = file.listFiles();
        for(int i=0;i<sourceFiles.length;i++){
            if (sourceFiles[i].isFile()){
                try {
                    FileInputStream fileInputStream = new FileInputStream(sourceFiles[i]);
                    File pathFile = new File(path);
                    File newFile = new File(path+sourceFiles[i].getName());
                    if (!pathFile.exists()){
                        pathFile.mkdirs();
                    }
                    if (!newFile.exists()){
                        newFile.createNewFile();
                    }
                    //新文件输出流
                    FileOutputStream fileOutputStream = new FileOutputStream(newFile);

                    byte[] buffer= new byte[1024];
                    int len;
                    //将文件流信息读取文件缓存区，如果读取结果不为-1就代表文件没有读取完毕，反之已经读取完毕
                    while ((len=fileInputStream.read(buffer))!=-1) {
                        fileOutputStream.write(buffer, 0, len);

                        fileOutputStream.flush();

                    }
                    fileInputStream.close();
                    fileOutputStream.close();
                    System.out.println("SUCCESS!");
                } catch (IOException e) {
                    log.info("解密异常",e);
                }

            }
        }
        }
}
~~~





