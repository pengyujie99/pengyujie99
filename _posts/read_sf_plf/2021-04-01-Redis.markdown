---
layout:     post
title:      "NOSQL数据库Redis"
subtitle:   "缓存 穿透、击穿与雪崩"
date:       2021-4-1 12:00:00
author:     "Pengyujie"
header-img: "img/tag-bg.jpg"
tags:
    - Java
    - 中间件
---

>redis为什么单线程还那么快？
>redis是将数据放在内存的，多线程如果cpu不足，则会发生cpu上下文切换，非常耗时，
>对于内存来说没有上下文切换，多次读写都是在一个cpu上的，在内存情况下，这个就是最佳方案.

## 概述
<div >
    <br><b>NOSQL概述</b>
	<br>为什么要用NOSQL?
	<br>现在已经是2021年了，是大数据时代，一般数据库已经无法进行分析处理了！
	<br>90年代一个基本网站，访问量不大，单个数据库完全足够。
	<br>
	<br>1.数据量太大，一个机器放不下
	<br>2.数据索引建立（B+Tree）
	<br>3.访问量读写混合，一个服务器承受不了
	<br>当存在以上问题的时候就需要晋级了
    <ul>Redis的五大基本数据类型
        <li><b>String</b>
		</li>
		<li><b>List</b>
        </li>
		<li><b>Set</b>
        </li>
		<li><b>Hash</b>
        </li>
		<li><b>Zset</b>
        </li>
    </ul>
	<ul>三种特殊的数据类型
        <li><b>geospatial（地图、地址类型）</b>
		</li>
		<li><b>hyperloglog 基数统计</b>
        </li>
		<li><b>bitmaps 位存储</b>
        </li>
    </ul>
</div>
## 主从复制和哨兵模式
<div>
	<br>主从复制，读写分离
    <br>只能由主节点进行写操作，从节点是进行读操作的（主节点以写为主，从节点以读为主）
    <br>
    <br>主从复制的作用
    <br>1.数据冗余
    <br>2.故障恢复
    <br>3.负载均衡
    <br>4.高可用基石：主从复制是哨兵模式和集群实施的基础，所以说主从复制也是redis高可用的基础
    <br>配置redis集群，至少需要三台服务器，一主二从
    <br>
	<br>哨兵模式
	<br>当主服务器宕机之后，需要手动把一台服务器设备为主服务器，这时就需要人工干预，还会造成一段时间服务不可用。
	<br>这时候我们推荐使用哨兵模式，Redis从Redis2.8之后提供了sentinel（哨兵）架构来解决这个问题。
	<br>哨兵模式是一种特殊的模式，能够后台自动监控主机是否出现问题，如果出现故障，会根据投票票数，将从库转换为主库，如果主库好了之后回来也只能当做新主库的从库。
	<br>哨兵是一个独立的进程，作为进程他会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。
	<br>
</div>

## Redis核心

RDB  

由于Redis是内存数据库，断电即失，需要将数据进行存储。  
rdb是在满足一定要求之后进行创建rdb文件，当再次启动redis会自定运行rdb文件恢复数据。  
满足以下条件之一即可进行rdb持久化。  
```
1.当满足save的规则之后便会触发产生一个dump.rdb文件，在配置中进行定义。
2.执行flushall
3.退出redis
```
优点：  
性能更好，占用内存更小，恢复更快。    

缺点：  
当服务器意外宕机之后可能丢掉最后一次的数据。    

AOF    

aof默认是不开启的，需要在配置里进行手动配置。可以配置进行记录间隔的时间。  
aof是将用户进行的所有命令都进行记录，重启时，根据aof文件记录的命令重新执行一遍来恢复数据。  
aof文件数据被破坏时，可以利用redis-check-aof  --fix进行修复，这样可能会丢失部分数据。    

优点：  
每一段时间都进行同步，数据完整性更好。    

缺点：  
aof体积大，恢复效率和运行效率要比rdb慢，且可能会丢失最后一段时间的数据。    

## 缓存
<div>
    <br>一、缓存穿透（查不到）
	<br>当查询数据在缓存中没有，就会去请求数据库查询，数据库中也没有时，查询失败。当用户很多的时候，就会给持久层数据库带来巨大的压力，这就相当于出现了缓存穿透。
	<br>解决方案：
	<br>布隆过滤器：在进行入缓存查询时，将不符合的直接丢弃。
	<br>缓存空对象：即失败之后，将这个对象作为一个空对象缓存起来，同时设置一个过期时间，当再次访问，就会从这个缓存读取，保护了后端数据库。
	<br>
	<br>
	<br>二、缓存击穿（高并发）
	<br>当一个key被持续高并发，当着key失效的瞬间，持续的大并发就会击穿缓存，直接请求数据库。比如：微博热搜！
	<br>解决方案：
	<br>设置热点数据永不过期
	<br>加互斥锁：保证同一时间只有一个线程会进入查询数据库
	<br>
	<br>三、缓存雪崩 （缓存的集体失效或者Redis宕机）
	<br>当数据集体失效时候，查询数据就会直接对数据库访问。比如双十一
	<br>解决方案：
	<br>Redis高可用：多增加几台Redis
	<br>限流降级：
	<br>数据预热：不同时间失效
    <br>
    <br><b>个人理解：击穿就是让查询到达了数据库。(一般来讲查询应该是在缓存实现来缓解服务器压力)</b>
	<br><b>击穿则是当一个数据缓存查不到的时候，大量的高并发持续去访问这一个数据。</b>
    <br><b>缓存雪崩和击穿一样，只是是大量数据。</b>
</div>
