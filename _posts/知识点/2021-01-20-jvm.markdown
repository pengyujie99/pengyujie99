---
layout:     post
title:      "JVM"
subtitle:   "JVM"
date:       2021-03-16 12:00:00
author:     "Pengyujie"
header-img: "img/tag-bg.jpg"
tags:
    - JVM
    - Java

---

>对JVM的初步认识。以jdk1.8为例 

<img src="../../../../../img/notes/blog-desktop.jpg" >



java代码首先由jdk编译为`.class`字节码文件,随后由jvm将字节码文件转为机器可以识别的二进制文件。



JVM是用来

<b>JVM构成</b>

​	* 类加载器

​	* 运行时数据区（五大组成）

&ensp; &ensp; &ensp; 1. 程序计数器

&ensp; &ensp; &ensp; 2. 虚拟机栈

&ensp; &ensp; &ensp; 3. 堆

&ensp; &ensp; &ensp; 4. 方法区

&ensp; &ensp; &ensp; 5. 本地方法栈

​	* 执行引擎

​	* 本地库接口

![img](../../../../../img/notes/jvm/jvm.png)



<b>功能作用</b>

Java程序首先被编译成.class文件



加载 - 验证（验证.class文件是否符合规范） - 准备（给静态变量分配地址空间 和默认值） - 解析（符号引用变为直接引用 比如将main()方法 替换为指向数据所存内存的指针或句柄)- 初始化（将静态变量的初始值化为指定的值 执行代码逻辑）

<b>类加载器</b>作用就是加载class文件,将其加载到<b>运行时数据区</b>，
然后由<b>执行引擎</b>将字节码（class文件）翻译成底层系统指令给CPU去
执行，在这个过程中需要调用其他语言的接口<b>本地库接口</b>来实现整个
程序的功能。



## 类加载器



* 虚拟机自带的加载器

* 启动类（根）加载器

* 扩展类加载器

* 应用程序加载器

<b>双亲委派机制</b>
new一个类之后当前加载器就会将其抛给父类 一层一层抛给boot加载器进行查询。
boot加载器没有，就给下一级ext加载器查询，没有再给app加载器查询，过程中只要查询到就执行。
![img](../../../../../img/notes/jvm/jvm_1.png)



## 运行时数据区（五大组成）





<b>程序计数器</b>

<b>内存私有</b>

是一块较小的内存空间，可以当做一个当前线程的所执行字节码的信号指示器

<b>方法区</b>
<b>内存共享</b>
用于存储以及被虚拟机加载的类信息、运行时常量池、即时编译后的代码数据。反射就是从这方法区读取类信息。

<b>堆</b>
<b>内存共享</b>
堆是Java虚拟机中<b>内存最大</b>的一块,用于存放对象实例、静态变量、字符串常量。

<b>Java虚拟机栈</b>
<b>内存私有</b>
每一个方法在执行的同时都会创建一个线帧，<b>用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</b>
每一个方法从调用到执行完毕,都对应着一个线帧在虚拟机栈从入栈到出栈的全过程。

<b>本地方法栈</b>
<b>内存私有</b>
与虚拟机栈类型，本地方法栈的线帧存储的是本地方法的信息。



### GC算法 

**标记清除法：**    
进行一次扫描对进行需要活着的对象进行标记，再一次扫描对进行没有标记的对象进行清除。  
好处：不需要额外空间。  
坏处：二次扫描严重浪费时间，会产生内存碎片。  

**标记整理：**  
就是在标记清除算法的基础上进行一次压缩整理。

好处：不需要额外空间，没有内存碎片

坏处：效率低

**复制算法：**  
可以将一个区的数据 转移到另一个区 ，保证一个区的绝对干净（年轻代主要用的为复制算法：将to区复制到from区 保证了to区的绝对干净）  

好处：没有内存碎片。  
坏处：浪费内存空间，一半内存空间永远是空to。  
谁空谁是to  

**内存效率：复制算法最优  
内存整齐度：复制算法  
内存利用率：标记压缩和标记压缩**  

缺点：  
标记清除算法会出现内存碎片。  
标记整理算法效率太低。  
复制算法，浪费内存。  



## 执行引擎

是jvm非常核心的组件，用来执行jvm字节码，一般会编译成机器码后执行。




## 本地库接口

调用其他语言本地方法的接口。由接口调用本地方法库去实现程序功能。





## 栈的使用

![img](../../../../../img/notes/jvm/1.png)

---



**栈是内存私有的，每个线程都有自己对应的栈，线程会分配一个栈，内部存储对应的局部变量含形参（这个线程每个方法都会在栈中分配一个对应的栈帧来存储这个方法执行过程中的局部变量）**

**对象存放于堆，那么局部变量引用对象，那么栈中的局部变量就会指向堆中对应的对象**

**方法区中存放的是 常量、静态变量、类信息 ，如果是静态变量引用的对象 那么就是方法区中的静态变量指向堆中的方法区**

**PC计数器用来存储，此时执行的代码的内存地址。用于下次上下文切换时，代码继续执行**



---

例子：

比如一个主线程Main方法内部调用一个A方法

~~~java
package com.example.reentrantlock;

public class Test {
    public static void main(String[] args) {
        int a = 1;
        int b = 2;
        int c = 3;

        Test test = new Test();
        test.A();
    }

    public void A(){
        int d = 4;
    }
}

~~~



比如上方的Main方法执行，对应主线程的栈就会有 **main方法的栈帧和对应A方法的栈帧去存对应的变量**。



## 垃圾收集器



**新生代收集器：**

Serial
ParNew
Parallel Scavenge



**老年代收集器：**

Serial Old
Parallel Old
CMS
堆内存垃圾收集器：G1



### 新生代垃圾收集器

#### Serial

单线程收集器，复制算法，用户线程都执行到安全点时，所有线程暂停执行，Serial 收集器以单线程，采用复制算法进行垃圾收集工作，收集完之后，用户线程继续开始执行。

适用场景：Client 模式（桌面应用）；单核服务器。

可以用 -XX:+UserSerialGC 来选择 Serial 作为新生代收集器。



#### ParNew

多线程收集器，复制算法，可以理解为Serial的多线程版本，其它与Serial并无区别。ParNew 在单核 CPU 环境并不会比 Serial 收集器达到更好的效果，它默认开启的收集线程数和 CPU 数量一致，可以通过 -XX:ParallelGCThreads 来设置垃圾收集的线程数。

适用场景：多核服务器；与 CMS 收集器搭配使用。当使用 -XX:+UserConcMarkSweepGC 来选择 CMS 作为老年代收集器时，新生代收集器默认就是 ParNew，也可以用 -XX:+UseParNewGC 来指定使用 ParNew 作为新生代收集器。



#### Parallel Scavenge

多线程收集器，复制算法，与 ParNew 的不同之处是ParNew 的目标是尽可能缩短垃圾收集时用户线程的停顿时间，Parallel Scavenge 的目标是达到一个可控制的吞吐量。可以通过 -XX:MaxGCPauseMillis 来设置收集器尽可能在多长时间内完成内存回收，可以通过 -XX:GCTimeRatio 来精确控制吞吐量。

适用场景：注重吞吐量，高效利用 CPU，需要高效运算且不需要太多交互。

可以使用 -XX:+UseParallelGC 来选择 Parallel Scavenge 作为新生代收集器，jdk7、jdk8默认使用 Parallel Scavenge 作为新生代收集器。



### 老年代垃圾收集器

#### Serial Old

单线程收集器，标记整理算法

适用场景：Client 模式（桌面应用）；单核服务器；与 Parallel Scavenge 收集器搭配；作为 CMS 收集器的后备预案。



#### Parallel Old

多线程收集器，标记整理算法，Parallel Old 收集器是 Parallel Scavenge 的老年代版本，可以与 Parallel Scavenge 收集器搭配，可以充分利用多核 CPU 的计算能力。

适用场景：与Parallel Scavenge 收集器搭配使用；注重吞吐量。jdk7、jdk8 默认使用该收集器作为老年代收集器，使用 -XX:+UseParallelOldGC 来指定使用 Paralle Old 收集器。



#### CMS

标记清除算法，CMS 收集器是一种以最短回收停顿时间为目标的收集器，以 “ 最短用户线程停顿时间 ” 著称。整个垃圾收集过程分为 4 个步骤：

① 初始标记：标记一下 GC Roots 能直接关联到的对象，速度较快。

② 并发标记：进行 GC Roots Tracing，标记出全部的垃圾对象，耗时较长。

③ 重新标记：修正并发标记阶段引用户程序继续运行而导致变化的对象的标记记录，耗时较短。

④ 并发清除：用标记-清除算法清除垃圾对象，耗时较长。

整个过程耗时最长的并发标记和并发清除都是和用户线程一起工作，所以从总体上来说，CMS 收集器垃圾收集可以看做是和用户线程并发执行的。

CMS 收集器也存在一些缺点：

对 CPU 资源敏感：默认分配的垃圾收集线程数为（CPU 数+3）/4，随着 CPU 数量下降，占用 CPU 资源越多，吞吐量越小

无法处理浮动垃圾：在并发清理阶段，由于用户线程还在运行，还会不断产生新的垃圾，CMS 收集器无法在当次收集中清除这部分垃圾。同时由于在垃圾收集阶段用户线程也在并发执行，CMS 收集器不能像其他收集器那样等老年代被填满时再进行收集，需要预留一部分空间提供用户线程运行使用。当 CMS 运行时，预留的内存空间无法满足用户线程的需要，就会出现 “ Concurrent Mode Failure ”的错误，这时将会启动后备预案，临时用 Serial Old 来重新进行老年代的垃圾收集。

因为 CMS 是基于标记-清除算法，所以垃圾回收后会产生空间碎片，可以通过 -XX:UserCMSCompactAtFullCollection 开启碎片整理（默认开启），在 CMS 进行 Full GC 之前，会进行内存碎片的整理。还可以用 -XX:CMSFullGCsBeforeCompaction 设置执行多少次不压缩（不进行碎片整理）的 Full GC 之后，跟着来一次带压缩（碎片整理）的 Full GC。

适用场景：重视服务器响应速度，要求系统停顿时间最短。可以使用 -XX:+UserConMarkSweepGC 来选择 CMS 作为老年代收集器



#### G1

G1 收集器是 jdk1.7 才正式引用的商用收集器，现在已经成为 jdk9 默认的收集器。前面几款收集器收集的范围都是新生代或者老年代，G1 进行垃圾收集的范围是整个堆内存，它采用 “ 化整为零 ” 的思路，把整个堆内存划分为多个大小相等的独立区域（Region），在 G1 收集器中还保留着新生代和老年代的概念。

每一个方块就是一个区域，每个区域可能是 Eden、Survivor、老年代，每种区域的数量也不一定。JVM 启动时会自动设置每个区域的大小（1M ~ 32M，必须是 2 的次幂），最多可以设置 2048 个区域（即支持的最大堆内存为 32M*2048 = 64G），假如设置 -Xmx8g -Xms8g，则每个区域大小为 8g/2048=4M。

G1 收集器收集器收集过程有初始标记、并发标记、最终标记、筛选回收，和 CMS 收集器前几步的收集过程很相似：

① 初始标记：标记出 GC Roots 直接关联的对象，这个阶段速度较快，需要停止用户线程，单线程执行。

② 并发标记：从 GC Root 开始对堆中的对象进行可达新分析，找出存活对象，这个阶段耗时较长，但可以和用户线程并发执行。

③ 最终标记：修正在并发标记阶段引用户程序执行而产生变动的标记记录。

④ 筛选回收：筛选回收阶段会对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来指定回收计划（用最少的时间来回收包含垃圾最多的区域，这就是 Garbage First 的由来——第一时间清理垃圾最多的区块），这里为了提高回收效率，并没有采用和用户线程并发执行的方式，而是停顿用户线程。

适用场景：要求尽可能可控 GC 停顿时间；内存占用较大的应用。可以用 -XX:+UseG1GC 使用 G1 收集器，jdk9 默认使用 G1 收集器。



### 参数设置

-XX:+UseSerialGC：在新生代和老年代使用串行收集器

-XX:+UseParNewGC：在新生代使用并行收集器

-XX:+UseParallelGC ：新生代使用并行回收收集器，更加关注吞吐量

-XX:+UseParallelOldGC：老年代使用并行回收收集器

-XX:ParallelGCThreads：设置用于垃圾回收的线程数

-XX:+UseConcMarkSweepGC：新生代使用并行收集器，老年代使用CMS+串行收集器

-XX:ParallelCMSThreads：设定CMS的线程数量

-XX:+UseG1GC：启用G1垃圾回收器





## jvm调优

内存泄漏

windows环境 可以生成dump（可以任务管理器生成转储文件）然后使用内存分析工具进行分析包括 visual mat 等等

linux环境 使用命令生成dump 然后使用工具进行分析

也都可以启动的时候通过命令，当出现内存溢出的时候自动生成dump文件

实际内存泄漏排查，主要的就是生成对应的dump然后通过工具排查定位。



CPU占用过高

可以通过上面dump也可以通过命令定位，linux通过top，jstack定位到代码

windows可以通过任务管理器看到对应的pid，然后用Windows自带的`pslist -dmx pid`命令查看进程的线程信息

然后转为十六进制，通过jstack -l PID定位到对应代码。









































