---
layout:     post
title:      "问题"
subtitle:   "Java问题集合"
date:       2021-06-10
author:     "Pengyujie"
header-img: "img/tag-bg.jpg"
hidden: true
tags:
  - Java
  - 笔记

---

> 面试的部分笔记





#### **math.round的用法？**

四舍六入五看前面一位单双（单就进，双就舍）源码就是加上0.5之后向下取整。  



#### **IO与NIO**

IO是面向流的，NIO是面向块，也可以说是面向缓存的。

IO是阻塞的，比如当你在进行一个读写时，必须要等他做完，才可以做其他事情。NIO是不需要等它读写完毕就可以做其他事情，不会阻塞。

IO是没有选择器的，一个请求就对应一个线程。NIO可以使用选择器，用一个线程来管理多个通道。



#### **如何将字符串进行反转**

```java
public class Reverse {
    public static void main(String[] args) {
        String str = "pengyujie";
        StringBuffer sb = new StringBuffer();
        sb.append(str);
        System.out.println(sb.reverse());
    }
}
```



#### **Java线程的状态**

创建 等待 超时等待 运行 阻塞 销毁（源码中就是六种）



#### **进程的状态**

创建 就绪 运行 阻塞 销毁



#### **创建对象的几种方式**

1、直接new对象 。 2、利用反射获取class，调用newInstance()方法创建对象。  3、可以调用Constructor类的nnewInstance()方法来创建。4、反序列。



#### **spring ioc的几种注入方式**

1、setter注入。 2、接口注入。 3、构造器注入。



#### **mybatis的隔离级别**

 读未提交 不可重复读 可重复读 串行化  默认的级别是可重复读。

​		1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

　　2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。

　　3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

　　**小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表**



#### **spring mvc的五大组件**

DispatchServlet  HandlerMaping  Controller ViewResolve ModelAndView



#### **Java有哪些容器**

主要分为二大类：Collection和Map。

list和set实现了Collection接口，hashmap实现的是Map接口。



#### **什么是泛型，有什么优点**

泛型就是参数化数据类型，将数据类型指定为一个参数。

好处：类型安全、避免了强制类型转换、性能也更好一点。



#### **get和post**

get请求会将请求参数放在url中，url的长度也是有限的。post是以请求体的形式去传递参数。

退回页面时，get直接退回，post需要重新提交请求。



#### **类加载的过程**

加载：将.calss文件加载到jvm。

链接：1、验证：验证字节流是否符合规范。 2、准备：分配内存空间，并赋初始值。3、解析：将符号引用变为直接引用、引用指向内存地址。

初始化：开始执行代码逻辑。



#### **pc计数器的作用**

保证程序的顺利执行，它记录的是下一条执行的指令。



#### **list的循环输出方式**

```java
public class Iterator {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);

        //for循环
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
        System.out.println("------------------");

        //增强for循环
        for (Integer integer : list) {
            System.out.println(integer);
        }
        System.out.println("------------------");

        //迭代器
        java.util.Iterator<Integer> iterator = list.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}
```



#### **SQL语句 DML语句**

```sql
--DML语句
--表操作
CREATE TABLE B--创建表
(ID INT,
NAME VARCHAR(20));

DELETE B--删除表内容
ALTER TABLE B ADD email Varchar(20);--表添加一个字段

DELETE FROM B--删除表内容
DELETE B--删除表内容
TRUNCATE TABLE B --删除表内容 保留结构，与上面的区别是无法rollback 和hwm标记复位

ALTER TABLE B ADD email Varchar(20);--表添加一个字段
DROP TABLE B; --删除表
ALTER TABLE B DROP COLUMN email;--表删除一个字段
--数据操作
INSERT INTO B VALUES(1,'zhangsan');--添加一行数据
INSERT INTO B VALUES(2,'lisi');
INSERT INTO B VALUES(3,'pengyujie',1933799087)
DELETE --删除一行数据
FROM B
WHERE B.Id=1
UPDATE B SET email='1933799087@qq.com'--修改数据
WHERE B.ID=3
SELECT * FROM B ;--查询
--用户
GRANT USER user_name IDENTIFIED BY user_password--创建用户
GRANT CREATE TABLE TO user_name--授权给用户
-----
```



#### 分布式锁

> 能够实现多台机器中线程对共享资源的互斥访问

比如Redis的发布订阅、MySQL中多个线程连接同一个数据库，然后通过行锁实现互斥访问。都可以很好地实现分布式锁。

业内有三种实现方式：

1、基于数据库；

2、基于redis；

3、基于Zookeeper。



#### RPC

> 远程过程调用

可以使用httpclient（基于http的）去实现，也可以使用基于TCP/UDP协议的。



#### 防止死锁

1、设置加锁顺序，保证按顺序执行

2、设置加锁时长

3、进行死锁检查，保证确保第一时间发现死锁并进行解决



#### JSONObject.toJSONString()和toString()的区别 

前者相当于先toJSON然后toString。

~~~JAVA
List<Map> list =new ArrayList<>();
        Map<String,String> map = new HashMap<>();
        map.put("goods_id","1");
        map.put("goods_name","东山公寓3102-水电费充值");
        map.put("quantity","");
        map.put("price","");
        list.add(map);
        String str1 = list.toString();
        System.out.println("toString:"+str1);
        String str = JSONObject.toJSONString(list);
        System.out.println("toJSONString:"+str);
~~~



<img src="\img\notes\notes\1.png">



#### Redis多路复用

<img src="\img\notes\notes\2.png">



产生原因：因为redis为单线程数据库，当有I/O事件时，如果发生阻塞就无法为其他请求提供服务。这时候就需要用到多路复用

这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。多路复用实际就是监听每个I/O事件的状态，当系统通知这个I/O可读或者

可写之后才去执行，保证每次执行都是有用功，提高处理效率。一般用select，poll，epoll来做I/O事件监听的函数。





#### volatile

二个特性： 线程可见性、防止指令重排序

线程可见性：就是这个线程改变的值，在另一个线程获取不到（获取到的是未改变的值）

指令重排序：也就是防止代码内部逻辑顺序改变



可见性

~~~java
package com.example.demo.weixin;

import java.util.concurrent.TimeUnit;

public class VolatileTest01 {
    /*volatile*/ boolean flag = true;

    void running(){
        System.out.println("start!!!");
        while(flag){
        }
        System.out.println("end!!!");
    }

    public static void main(String[] args) {
        VolatileTest01 t = new VolatileTest01();
        new Thread(t::running,"running").start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        t.flag=false;
    }
}
~~~

没有volatile 就无法获取到主线程改变的flag的值，那么线程就一直无法end！！！

加上volatile  一秒之后就会获取到flag改变后的值（可见性），线程就会end！！！。



重排序

~~~java
public class ResortSeqDemo {
    int a= 0;
    boolean flag = false;

    public void method01() {
        a = 1;
        flag = true;
    }

    public void method02() {
        if(flag) {
            a = a + 5;
            System.out.println("reValue:" + a);
        }
    }
}
~~~



~~~java
//正常顺序
a = 1;
flag = true;

a = a + 5;
System.out.println("reValue:" + a);


//重排序后可能导致顺序和我们预想的不一致
flag = true;

a = a + 5;
System.out.println("reValue:" + a);

a = 1;
~~~

这样顺序的不一样就导致结果就与实际不符合了。



#### throw和throws的区别

throws可以使多个异常，throw只能抛出一个异常

throws必须要进行抛出或捕获，否则会编译报错。throw抛出异常的方法，调用时可以不进行异常的抛出或捕获。

throws一般在方法头，throw在方法内。



#### 自旋锁

当去修改一个值时，需要先读取这个值是否为原来的值再去修改，如果发现已经被修改了就不能直接修改了，就需要再读一遍，然后再去修改。如果又被改变就继续上面操作循环。



#### JVM问题定位

~~~shell
jps   #查看系统中java进程号
jinfo 进程号	#打印信息
jstack 进程号	#查看进程所包含的线程 以及信息
~~~



#### 实体类中为什么要实现Serializable序列化接口

确切的说应该是对象的序列化，一般程序在运行时，产生对象，这些对象随着程序的停止运行而消失，但如果我们想把某些对象（因为是对象，所以有各自 不同的特性）保存下来，在程序终止运行后，这些对象仍然存在，可以在程序再次运行时读取这些对象的值，或者在其他程序中利用这些保存下来的对象。这种情况 下就要用到对象的序列化。

只有序列化的对象才可以存储在存储设备上。为了对象的序列化而需要继承的接口也只是一个象征性的接口而已，也就是说继承这个接口说明这个对象可以 被序列化了，没有其他的目的。**之所以需要对象序列化，是因为有时候对象需要在网络上传输，传输的时候需要这种序列化处理，从服务器硬盘上把序列化的对象取出，然后通过网络传到客户端，再由客户端把序列化的对象读入内存，执行相应的处理。**



#### CAP

就是一致性（Consistency）、可用性（Availability）和分区容错性（Partition）。CAP 理论告诉我们：**在一个分布式系统中，不可能同时满足一致性（Consistency)，可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足其中的2个**。

CA 一般在单体应用 ，CP是适合银行等对于一致性要求高的，AP是适合互联网项目，用户体验好。



#### tcp三次握手过程中可以携带数据吗？

其实第三次握手的时候，是可以携带数据的。但是，**第一次、第二次握手不可以携带数据**

为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。

也就是说，**第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。**

[tcp连接问题](https://juejin.cn/post/6844903958624878606)



#### Mybatis 传参方式：#{}和${}

我们经常使用的是#{},一般解说是因为这种方式可以防止SQL注入，简单的说#{}这种方式SQL语句是经过预编译的，它是把#{}中间的参数转义成字符串，举个例子：

select * from student where student_name = #{name} 

预编译后,会动态解析成一个参数标记符?

select * from student where student_name = ?

而使用${}在动态解析时候，会传入参数字符串

select * from student where student_name = 'lyrics'





#### 关于事务注解失效的问题

这里只写经常发生的情况（还有其他可能失效的没有写出）

-  Transactional注解标注方法修饰符为非public时
- 事务方法内部捕捉了异常，没有抛出新的异常
- 在类内部调用调用类内部@Transactional标注的方法

对于在类内部调用调用类内部@Transactional标注的方法，示例代码如下

~~~java
@Override
    public CommonResult createUser(UserDto userDto) {
        //类内部调用@Transactional标注的方法。
        insert(userDto);
        return CommonResult.builder().code(ResponseCode.SUCCESS.getCode()).message(ResponseCode.SUCCESS.getMessage()).build();
    }
    @Transactional
    public void insert(UserDto userDto) {
        User user = new User();
       BeanUtils.copyProperties(userDto,user);
        //正常public修饰符的事务方法
        userMapper.insert(user);
        int a = 1;
        if (a > 0) {
            throw new ApplicationException("-1", "新增失败", null);
        }
    }
~~~

注意：这里 是本类的createUser方法调用了本类的insert方法，使**本类的insert方法的事务注解没有生效**，如果此时在createUser上加上@Transactional注解，那么整个createUser方法也是有事务的。



举个简单的例子

~~~java
	@Override
    //@Transactional
    public void a() {
        SysUser sysUser = new SysUser();
        sysUser.setNickname("AAAA");
        sysUser.setAvatar("AAAA");
        this.sysUserMapper.insert(sysUser);
        b();
    }
    @Override
    @Transactional
    public void b(){
        SysUser sysUser = new SysUser();
        sysUser.setNickname("BBBB");
        sysUser.setAvatar("BBBB");
        this.sysUserMapper.insert(sysUser);
        String str = null;
        str.toString();//空指针

        SysUser sysUser1 = new SysUser();
        sysUser1.setNickname("CCCC");
        sysUser1.setAvatar("CCCC");
        this.sysUserMapper.insert(sysUser1);
    }
~~~

如果我们直接执行a()方法，数据库中就会**插入了A和B的数据，C并没有插入**(因为b方法的事务失效了)。

此时清空数据库，然后我们在a()方法加上事务注解，再调用a()方法，就会发现数据库中，**一条数据都没有插入**(因为a方法的事务生效了)



#### URL路径问题

访问遇到了一个之前的问题，之前解决但是忘了记录，想起来现在记录一下

首先先说一下设置图标的二种

- 全局设置为统一图标

在对应的根路径添加favicon.ico图标格式的文件。

- 对一个页面添加图标

在HTML中添加图片，不一定要ico格式文件。

~~~html
<link rel="icon" href="../images/favicon.ico" type="image/x-icon" />
~~~



问题：

当我们设置路径的时候，设置完成之后可以ctrl+点击  进入对应的资源的时候，我们以为是对的，但是我们启动项目结果资源404。

这时候可能是路径问题，比如当我设置favicon.ico的路径：为`../static/images/favicon.ico` 此时点击可以进去对应的资源。启动项目后图标没有出来图标资源404。

解决：如果我们将其改为`../images/favicon.ico` 点击并不能访问到对应的资源，但是启动后资源是可以获取到的。../ 是从根目录开始这里是从static目录开始。

**注意：对于favicon.ico来说，图片大小也不能过大，否则也是404，即使路径正确。**




#### [强缓存 和 协商缓存 原理](https://www.jianshu.com/p/9c95db596df5)





## 问题

`len=is.read(buffer)`不为-1

写了一个服务器来接收并打印对方传过来的信息，发现`len=is.read(buffer)` 有数据时，正常返回数据长度，当 is  没有数据时，再次执行并不会为-1，而是直接在这里阻塞了，不在往下执行。

个人分析  由于接受的is不是对方 getoutstream过来的 所以read方法去读就算没数据 也不会返回-1

~~~java
package com.service;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class ServiceSocket {
    public static void main(String[] args) {
        ServerSocket serverSocket =null;
        Socket socket=null;
        InputStream is =null;
        ByteArrayOutputStream baos =null;

        while(true){
            try {
                //1 创建一个服务器地址
                serverSocket = new ServerSocket(9999);
                //2 等待客户端连接过来
                socket = serverSocket.accept();
                Thread.sleep(5);
                //3 读取客户端传过来的消息
                is = socket.getInputStream();//is不是对方 outstream过来的 所以read就算没数据 也不会返回-1
                //管道流
                baos =new ByteArrayOutputStream();

                byte[] buffer =new byte[1024];
                int len =0;

                while((len=is.read(buffer)) != -1){//这一步 不动了
                    baos.write(buffer,0,len);
                    System.out.println("len:"+len);
                    //System.out.println(is.read(buffer));
                    System.out.println(baos.toString());
                }
                System.out.println("信息："+baos.toString());//这一步永远无法执行
            }catch (IOException | InterruptedException e){
                e.printStackTrace();
            }finally {
                if(baos!=null){
                    try {
                        baos.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
                if(is!=null){
                    try {
                        is.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
                if(socket!=null){
                    try {
                        socket.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
                if(serverSocket!=null){
                    try {
                        serverSocket.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println("异常了！！");
            }

        }
    }
}
~~~







### 前端：

#### ajax返回信息 不走success走error 

证明可能请求格式不对  比如以application/json格式请求 后端接口是 application/html格式 就会报404错误 请求不到对应接口

解决：需要改请求格式或者接口其中一个即可（可在后端使用注解@ResponseBody   来控制为json格式）





















